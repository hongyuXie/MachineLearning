# 梯度下降直观感受
## 视频
<video height=510 width=900 controls="controls" preload="none">
      <source src="amWiki/videos/001/01-Week1/4-Parameter Learning/2-Gradient Descent_1.mp4" type="video/mp4">
</video>
## 中文
### 理解梯度下降算法中的微分项
![理解梯度下降算法中的微分项](amWiki/images/001/01-Week1/4-Parameter Learning/7_理解梯度下降算法中的微分项.jpg)
在之前的视频中 我们给出了一个数学上关于梯度 下降的定义 本次视频我们更深入研究一下 更直观地感受一下这个 算法是做什么的 以及梯度下降算法的更新过程有什么意义 这是我们上次视频中看到的梯度下降算法 提醒一下 这个参数 α 术语称为学习速率 它控制我们以多大的幅度更新这个参数θj. 第二部分是导数项 而我在这个视频中要做的就是 给你一个更直观的认识 这两部分有什么用 以及 为什么当把 这两部分放一起时 整个更新过程是有意义的 为了更好地让你明白 我要做是用一个稍微简单的例子 比如我们想最小化的那个 函数只有一个参数的情形 所以 假如我们有一个代价函数J 只有一个参数 θ1 就像我们前几次视频中讲的 θ1是一个实数 对吧？
### 通过例子理解梯度下降算法中的微分项
![通过例子理解梯度下降算法中的微分项](amWiki/images/001/01-Week1/4-Parameter Learning/8_通过例子理解梯度下降算法中的微分项.jpg)
那么我们可以画出一维的曲线 看起来很简单 让我们试着去理解 为什么梯度下降法 会在这个函数上起作用 所以 假如这是我的函数 关于θ1的函数J θ1是一个实数 对吧？ 现在我们已经对这个点上用于梯度下降法的θ1 进行了初始化 想象一下在我的函数图像上 从那个点出发 那么梯度下降 要做的事情是不断更新 θ1等于θ1减α倍的 d/dθ1J(θ1)这个项 对吧？哦 顺便插一句 你知道 这个微分项是吧？可能你想问为什么我改变了符号 之前用的是偏导数的符号 如果你不知道偏导数的符号 和d/dθ之间的区别是什么 不用担心 从技术上讲 在数学中 我们称这是一个偏导数 这是一个导数 这取决于函数J的参数数量 但是这是一个 数学上的区别 就本课的目标而言 可以默认为 这些偏导数符号 和d/dθ1是完全一样的东西 不用担心 是否存在任何差异 我会尽量使用数学上的 精确的符号 但就我们的目的而言 这些符号是没有区别的 好的 那么我们来看这个方程 我们要计算 这个导数 我不确定之前你是否在微积分中学过导数 但对于这个问题 求导的目的 基本上可以说 取这一点的切线 就是这样一条红色的直线 刚好与函数相切于这一点 让我们看看这条红色直线的斜率 其实这就是导数 也就是说 直线的斜率 也就是这条 刚好与函数曲线相切的这条直线 这条直线的斜率正好是 这个高度除以这个水平长度 现在 这条线有 一个正斜率 也就是说它有正导数 因此 我得到的新的θ θ1更新后等于θ1减去一个正数乘以α. α 也就是学习速率也是一个正数 所以 我要使θ1减去一个东西 所以相当于我将θ1向左移 使θ1变小了 我们可以看到 这么做是对的 因为实际上我往这个方向移动 确实让我更接近那边的最低点 所以 梯度下降到目前为止似乎 是在做正确的事 让我们来看看另一个例子 让我们用同样的函数J 同样再画出函数J(θ1)的图像 而这次 我们把参数初始化到左边这点 所以θ1在这里 同样把这点对应到曲线上 现在 导数项d/dθ1J(θ1) 在这点上计算时 看上去会是这样 这条线的斜率 这个导数是这条线的斜率 但是这条线向下倾斜 所以这条线具有负斜率 对吧？ 或者说 这个函数有负导数 也就意味着在那一点上有负斜率 因此 这个导数项小于等于零 所以 当我更新θ时 θ被更新为θ减去α乘以一个负数 因此我是在用 θ1减去一个负数 这意味着我实际上是在增加θ1 对不对？因为这是减去一个负数 意味着给θ加上一个数 这就意味着最后我实际上增加了θ的值 因此 我们将 从这里开始 增加θ 似乎这也是我希望得到的 也就是 让我更接近最小值了 所以 我希望这样很直观地给你解释了 导数项的意义
### 理解梯度下降算法中的学习速率α
![理解梯度下降算法中的学习速率α](amWiki/images/001/01-Week1/4-Parameter Learning/9_理解梯度下降算法中的学习速率α.jpg)
让我们接下来再看一看学习速率α 我们来研究一下它有什么用 这就是我梯度下降法的 更新规则 就是这个等式 让我们来看看如果α 太小或 α 太大  会出现什么情况 这第一个例子 α太小会发生什么呢 这是我的函数J(θ) 就从这里开始 如果α太小了 那么我要做的是要去 用一个比较小的数乘以更新的值 所以最终 它就像一个小宝宝的步伐 这是一步 然后从这个新的起点开始 迈出另一步 但是由于α 太小 因此只能迈出另一个 小碎步 所以如果我的学习速率太小 结果就是 只能这样像小宝宝一样一点点地挪动 去努力接近最低点 这样就需要很多步才能到达最低点 所以如果α 太小的话 可能会很慢 因为它会一点点挪动 它会需要 很多步才能到达全局最低点 那么如果α 太大又会怎样呢 这是我的函数J(θ) 如果α 太大 那么梯度下降法可能会越过最低点 甚至可能无法收敛 我的意思是 比如我们从这个点开始 实际上这个点已经接近最低点 因此导数指向右侧 但如果α 太大的话 我会迈出很大一步 也许像这样巨大的一步 对吧？所以我最终迈出了一大步 现在 我的代价函数变得更糟 因为离这个最低点越来越远 现在我的导数指向左侧 实际上在减小θ 但是你看 如果我的学习速率过大 我会移动一大步 从这点一下子又到那点了 对吗？如果我的学习率太大 下一次迭代 又移动了一大步 越过一次 又越过一次 一次次越过最低点 直到你发现 实际上 离最低点越来越远 所以 如果α太大 它会导致无法收敛 甚至发散
### 内嵌习题_初始值为局部最小值的梯度下降算法
现在 我还有一个问题 这问题挺狡猾的 当我第一次学习这个地方时 我花了很长一段时间才理解这个问题 如果我们预先把θ1 放在一个局部的最低点
![内嵌习题_初始值为局部最小值的梯度下降算法](amWiki/images/001/01-Week1/4-Parameter Learning/10_内嵌习题_初始值为局部最小值的梯度下降算法.jpg)
你认为下一步梯度下降法会怎样工作？
### 内嵌习题解答_初始值为局部最小值的梯度下降算法
![内嵌习题解答_初始值为局部最小值的梯度下降算法](amWiki/images/001/01-Week1/4-Parameter Learning/11_内嵌习题解答_初始值为局部最小值的梯度下降算法.jpg)
所以假设你将θ1初始化在局部最低点 假设这是你的θ1的初始值 在这儿 它已经在一个局部的 最优处或局部最低点 结果是局部最优点的导数 将等于零 因为它是那条切线的斜率 而这条线的斜率将等于零 因此 此导数项等于0 因此 在你的梯度下降更新过程中 你有一个θ1 然后用θ1 减α 乘以0来更新θ1 所以这意味着什么 这意味着你已经在局部最优点 它使得θ1不再改变 也就是新的θ1等于原来的θ1 因此 如果你的参数已经处于 局部最低点 那么梯度下降法更新其实什么都没做 它不会改变参数的值 这也正是你想要的 因为它使你的解始终保持在 局部最优点 这也解释了为什么即使学习速率α 保持不变时 梯度下降也可以收敛到局部最低点 我想说的是这个意思
### 举例说明梯度下降算法在接近局部最优点时自动减小学习速率α
![举例说明梯度下降算法在接近局部最优点时自动减小学习速率α](amWiki/images/001/01-Week1/4-Parameter Learning/12_举例说明梯度下降算法在接近局部最优点时自动减小学习速率α.jpg)
我们来看一个例子 这是代价函数J(θ) 我想找到它的最小值 首先初始化我的梯度下降算法 在那个品红色的点初始化 如果我更新一步梯度下降 也许它会带我到这个点 因为这个点的导数是相当陡的 现在 在这个绿色的点 如果我再更新一步 你会发现我的导数 也即斜率 是没那么陡的 相比于在品红点 对吧？因为随着我接近最低点 我的导数越来越接近零 所以 梯度下降一步后 新的导数会变小一点点 然后我想再梯度下降一步 在这个绿点我自然会用一个稍微 跟刚才在那个品红点时比 再小一点的一步  现在到了新的点 红色点 更接近全局最低点了 因此这点的导数会比在绿点时更小 所以  我再进行一步梯度下降时 我的导数项是更小的 θ1更新的幅度就会更小 所以你会移动更小的一步 像这样 随着梯度下降法的运行  你移动的幅度会自动变得越来越小 直到最终移动幅度非常小 你会发现 已经收敛到局部极小值 所以回顾一下 在梯度下降法中 当我们接近局部最低点时 梯度下降法会自动采取 更小的幅度 这是因为当我们接近局部最低点时 很显然在局部最低时导数等于零 所以当我们 接近局部最低时 导数值会自动变得越来越小 所以梯度下降将自动采取较小的幅度 这就是梯度下降的做法 所以实际上没有必要再另外减小α 这就是梯度下降算法 你可以用它来最小化 最小化任何代价函数J 不只是线性回归中的代价函数J 在接下来的视频中 我们要用代价函数J 回到它的本质 线性回归中的代价函数 也就是我们前面得出的平方误差函数 结合梯度下降法 以及平方代价函数 我们会得出第一个机器学习算法 即线性回归算法

## English
### Understand derivative term in Gradient Descent Algorithm
![Understand derivative term in Gradient Descent Algorithm](amWiki/images/001/01-Week1/4-Parameter Learning/7_理解梯度下降算法中的微分项.jpg)
In the previous video, we gave a mathematical definition of gradient descent. Let's delve deeper and in this video get better intuition about what the algorithm is doing and why the steps of the gradient descent algorithm might make sense.Here's a gradient descent algorithm that we saw last time and just to remind you this parameter, or this term alpha is called the learning rate. And it controls how big a step we take when updating my parameter theory j.And this second term here is the derivative term. And what I wanna do in this video is give you that intuition about what each of these two terms is doing and why when put together, this entire update makes sense. In order to convey these intuitions, what I want to do is use a slightly simpler example, where we want to minimize the function of just one parameter. So say we have a cost function, j of just one parameter, theta one, like we did a few videos back, where theta one is a real number. So we can have one d plots, which are a little bit simpler to look at. Let's try to understand what gradient decent would do on this function.
### Through examples to understand derivative term in Gradient Descent Algorithm
![Through examples to understand derivative term in Gradient Descent Algorithm](amWiki/images/001/01-Week1/4-Parameter Learning/8_通过例子理解梯度下降算法中的微分项.jpg)
So let's say, here's my function, J of theta 1. And so that's mine. And where theta 1 is a real number.All right? Now, let's have in this slide its grade in descent with theta one at this location. So imagine that we start off at that point on my function. What grade in descent would do is it will update.Theta one gets updated as theta one minus alpha times d d theta one J of theta one, right? And as an aside, this derivative term, right, if you're wondering why I changed the notation from these partial derivative symbols. If you don't know what the difference is between these partial derivative symbols and the dd theta, don't worry about it. Technically in mathematics you call this a partial derivative and call this a derivative, depending on the number of parameters in the function J. But that's a mathematical technicality. And so for the purpose of this lecture, think of these partial symbols and d, d theta 1, as exactly the same thing. And don't worry about what the real difference is. I'm gonna try to use the mathematically precise notation, but for our purposes these two notations are really the same thing. And so let's see what this equation will do. So we're going to compute this derivative, not sure if you've seen derivatives in calculus before, but what the derivative at this point does, is basically saying, now let's take the tangent to that point, like that straight line, that red line, is just touching this function, and let's look at the slope of this red line. That's what the derivative is, it's saying what's the slope of the line that is just tangent to the function. Okay, the slope of a line is just this height divided by this horizontal thing. Now, this line has a positive slope, so it has a positive derivative. And so my update to theta is going to be theta 1, it gets updated as theta 1, minus alpha times some positive number. Okay. Alpha the the learning, is always a positive number. And, so we're going to take theta one is updated as theta one minus something. So I'm gonna end up moving theta one to the left. I'm gonna decrease theta one, and we can see this is the right thing to do cuz I actually wanna head in this direction. You know, to get me closer to the minimum over there. So, gradient descent so far says we're going the right thing. Let's look at another example. So let's take my same function J, let's try to draw from the same function, J of theta 1. And now, let's say I had to say initialize my parameter over there on the left. So theta 1 is here. I glare at that point on the surface. Now my derivative term DV theta one J of theta one when you value into that this point, we're gonna look at right the slope of that line, so this derivative term is a slope of this line. But this line is slanting down, so this line has negative slope. Right. Or alternatively, I say that this function has negative derivative, just means negative slope at that point. So this is less than equals to 0, so when I update theta, I'm gonna have theta. Just update this theta of minus alpha times a negative number. And so I have theta 1 minus a negative number which means I'm actually going to increase theta, because it's minus of a negative number, means I'm adding something to theta. And what that means is that I'm going to end up increasing theta until it's not here, and increase theta wish again seems like the thing I wanted to do to try to get me closer to the minimum. So this whole theory of intuition behind what a derivative is doing.
### Understand learning rate α in gradient descent Algorithm
![Understand learning rate α in gradient descent Algorithm](amWiki/images/001/01-Week1/4-Parameter Learning/9_理解梯度下降算法中的学习速率α.jpg)
Let's take a look at the rate term alpha and see what that's doing.So here's my gradient descent update mural, that's this equation.And let's look at what could happen if alpha is either too small or if alpha is too large. So this first example, what happens if alpha is too small? So here's my function J, J of theta. Let's all start here. If alpha is too small, then what I'm gonna do is gonna multiply my update by some small number, so end up taking a baby step like that. Okay, so this one step. Then from this new point, I'm gonna have to take another step. But if alpha's too small, I take another little baby step. And so if my learning rate is too small I'm gonna end up taking these tiny tiny baby steps as you try to get to the minimum. And I'm gonna need a lot of steps to get to the minimum and so if alpha is too small gradient descent can be slow because it's gonna take these tiny tiny baby steps and so it's gonna need a lot of steps before it gets anywhere close to the global minimum.Now how about if our alpha is too large? So, here's my function Jf filter, turns out that alpha's too large, then gradient descent can overshoot the minimum and may even fail to convert or even divert, so here's what I mean. Let's say it's all our data there, it's actually close to minimum. So the derivative points to the right, but if alpha is too big, I want to take a huge step. Remember, take a huge step like that. So it ends up taking a huge step, and now my cost functions have strong roots. Cuz it starts off with this value, and now, my values are strong in verse. Now my derivative points to the left, it says I should decrease data. But if my learning is too big, I may take a huge step going from here all the way to out there. So we end up being over there, right? And if my is too big, we can take another huge step on the next elevation and kind of overshoot and overshoot and so on, until you already notice I'm actually getting further and further away from the minimum. So if alpha is to large, it can fail to converge or even diverge.
### Exam_initial value in a local minimum
Now, I have another question for you. So this a tricky one and when I was first learning this stuff it actually took me a long time to figure this out.
![Exam_initial value in a local minimum](amWiki/images/001/01-Week1/4-Parameter Learning/10_内嵌习题_初始值为局部最小值的梯度下降算法.jpg)
What if your parameter theta 1 is already at a local minimum, what do you think one step of gradient descent will do?
### Answer_initial value in a local minimum
![Answer_initial value in a local minimum](amWiki/images/001/01-Week1/4-Parameter Learning/11_内嵌习题解答_初始值为局部最小值的梯度下降算法.jpg)
So let's suppose you initialize theta 1 at a local minimum. So, suppose this is your initial value of theta 1 over here and is already at a local optimum or the local minimum.It turns out the local optimum, your derivative will be equal to zero. So for that slope, that tangent point, so the slope of this line will be equal to zero and thus this derivative term is equal to zero. And so your gradient descent update, you have theta one cuz I updated this theta one minus alpha times zero. And so what this means is that if you're already at the local optimum it leaves theta 1 unchanged cause its updates as theta 1 equals theta 1. So if your parameters are already at a local minimum one step with gradient descent does absolutely nothing it doesn't your parameter which is what you want because it keeps your solution at the local optimum.
This also explains why gradient descent can converse the local minimum even with the learning rate alpha fixed.
### Example about gradient descent automatically decrease the learnning rate α
![Example about gradient descent automatically decrease the learnning rate α](amWiki/images/001/01-Week1/4-Parameter Learning/12_举例说明梯度下降算法在接近局部最优点时自动减小学习速率α.jpg)
Here's what I mean by that let's look in the example. So here's a cost function J of theta that maybe I want to minimize and let's say I initialize my algorithm, my gradient descent algorithm, out there at that magenta point. If I take one step in gradient descent, maybe it will take me to that point, because my derivative's pretty steep out there. Right? Now, I'm at this green point, and if I take another step in gradient descent, you notice that my derivative, meaning the slope, is less steep at the green point than compared to at the magenta point out there. Because as I approach the minimum, my derivative gets closer and closer to zero, as I approach the minimum. So after one step of descent, my new derivative is a little bit smaller. So I wanna take another step in the gradient descent. I will naturally take a somewhat smaller step from this green point right there from the magenta point. Now with a new point, a red point, and I'm even closer to global minimum so the derivative here will be even smaller than it was at the green point. So I'm gonna another step in the gradient descent.Now, my derivative term is even smaller and so the magnitude of the update to theta one is even smaller, so take a small step like so. And as gradient descent runs, you will automatically take smaller and smaller steps.Until eventually you're taking very small steps, you know, and you finally converge to the to the local minimum.So just to recap, in gradient descent as we approach a local minimum, gradient descent will automatically take smaller steps. And that's because as we approach the local minimum, by definition the local minimum is when the derivative is equal to zero. As we approach local minimum, this derivative term will automatically get smaller, and so gradient descent will automatically take smaller steps. This is what so no need to decrease alpha or the time.So that's the gradient descent algorithm and you can use it to try to minimize any cost function J, not the cost function J that we defined for linear regression. In the next video, we're going to take the function J and set that back to be exactly linear regression's cost function, the square cost function that we came up with earlier. And taking gradient descent and this great cause function and putting them together. That will give us our first learning algorithm, that'll give us a linear regression algorithm.
